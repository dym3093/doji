1、JDK动态代理生成对象的步骤：  
(1)获取被代理对象的引用，并且获取它的所有接口，反射获取。  
(2)JDK动态代理重新生成一个新的类，同时新的类要实现被代理类实现的所有接口。
(3)动态生成Java代码，新加的业务逻辑方法由一定的逻辑代码调用（在代码中体现）。  
(4)编译新生成的Java代码.class文件。  
(5)重新加载到JVM中运行。  
以上的过程叫字节码重组。  

2、CGLib代理执行代理方法的效率之所以比JDK的高，是因为CGLib采用了
FastClass机制，它的原理就是：为代理类和被代理类各生成一个类，这个类
会为代理类或被代理类的方法分屏一个index(int类型)；这个index当作一个
入参，FastClass就可以直接定位要调用的方法并直接进行调用，省去了反射调用，
所以调用效率比JDK代理通过反射调用高。

3、JDK的动态代理（依赖于接口）
1)在Java的动态代理机制中，有两个重要的类或接口，一个是InvocationHandler接口，另一个是Proxy类。
2)InvocationHandler接口是给动态代理类实现的，负责处理被代理对象的操作
3)Proxy类是用来创建动态代理类实例对象的，只有得到这个对象，才能调用需要代理的方法。
4)动态代理的代理类是在静态代理类上进行修改，将动态代理类实现InvocationHandler接口，重写Invoke方法，Invoke
方法通过传入的被代理类方法和参数来执行。

4、cglib动态代理（继承方式）
1)cglib动态代理中使用MethodInterceptor来实现动态代理类。
2)拦截器MethodInterceptor中就是由MethodProxy的invokeSuper方法调用代理方法的。
3)MethodProxy类生成代理方法和代理方法的签名。

5、JDK动态代理和Cglib动态代理的区别：  
1)JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。
2)Cglib因为是继承机制，所以无法代理被final修饰的方法。
3)JDK和Cglib都是在运行期间生产字节码，JDK是直接写class字节码，Cglib使用ASM框架写class字节码；cglib代理实现更复杂，生成代理类比JDK效率低。
4)JDK调用代理方法，是通过反射实现机制调用，cglib是通过FastClass机制直接调用方法，效率更高。

6、Spring中的代理选择原则：
1)当Bean有实现接口时，Spring就会用JDK动态代理。  
2)当Bean没有实现接口时，Spring会选择CGLib代理。
3)Spring可以通过配置强制使用CGLib代理，只需在Spring的配置文件中加入如下代码：
```xml
<aop:aspectj-autoproxy proxy-target-class="true"/>
```

7、静态代理和动态代理的本质区别：
1)静态代理只能通过手动完成代理操作，如果被代理类增加了心的方法，代理类需要同步增加，
违背开闭原则。
2)动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。
3)若动态代理要对目标类的增强逻辑进行扩展，结合策略模式，只需要新增策略类便可以完成，
无需修改代理类的代码。

8、代理模式优缺点  
优点：
1)代理模式能将代理对象与真实被调用目标对象分离。
2)在一定程度上降低了系统的耦合性，扩展性好。
3)可以起到保护目标对象的作用。
4)可以增强目标对象的功能。

缺点：  
1)代理模式会造成系统设计中类的数量增加。
2)在客户端和目标对象中增加一个代理对象，会导致请求处理速度变慢。
3)增加了系统复杂度。



